<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
  xmlns:e="http://schema.expertml.com/EarleyParser"
  exclude-result-prefixes="xs xd"
  version="3.0">
  
  <xd:doc scope="stylesheet">
    <xd:desc>
      <xd:p><xd:b>Created on:</xd:b> Jan 16, 2020</xd:p>
      <xd:p><xd:b>Author:</xd:b> Tomos FJ Hillman (TFJH)</xd:p>
      <xd:p>This stylesheet is a proof of concept Earley Parser designed to implement parsing using invisible XML grammars.</xd:p>
    </xd:desc>
  </xd:doc>
  
  <xsl:param name="input" as="xs:string" select="'{a=0}'"/>
  <xsl:param name="grammar" as="document-node(element(ixml))" select="document('Program.ixml')"/>
  
  <xd:doc>
    <xd:desc>Initial templates often don't work as expected...</xd:desc>
  </xd:doc>
  <xsl:template match="/">
    <xsl:call-template name="xsl:initial-template"/>
  </xsl:template>
  
  <xd:doc>
    <xd:desc>This template exists to run the initial POC parse operation</xd:desc>
  </xd:doc>
  <xsl:template name="xsl:initial-template">
    <xsl:sequence select="e:parse($input)"/>
  </xsl:template>
  
  <xsl:key name="ruleByName" match="rule" use="@name"/>
  
  <!-- parsing mode -->
  
  <xd:doc>
    <xd:desc>The first rule of any ixml grammar is taken as the starting symbol</xd:desc>
  </xd:doc>
  <xsl:template match="ixml" mode="e:parseTree">
    <e:parseTree>
      <xsl:apply-templates select="rule[1]" mode="#current"/>
    </e:parseTree>
  </xsl:template>
  
  <xd:doc>
    <xd:desc>Matching rules in the grammar</xd:desc>
  </xd:doc>
  <xsl:template match="rule" mode="e:parseTree">
    <xsl:element name="{replace(@name, '\s+', '_')}">
      <xsl:apply-templates mode="#current"/>
    </xsl:element>
  </xsl:template>
  
  <xd:doc>
    <xd:desc>Alternate branches are marked by retaining the alt element</xd:desc>
  </xd:doc>
  <xsl:template match="alt" mode="e:parseTree">
    <xsl:copy>
      <xsl:apply-templates select="child::*[1]" mode="#current"/>
    </xsl:copy>
  </xsl:template>
  
  <xd:doc>
    <xd:desc>Nonterminals redirect to other rules, then continues with any siblings.</xd:desc>
  </xd:doc>
  <xsl:template match="nonterminal" mode="e:parseTree">
    <xsl:apply-templates select="key('ruleByName', @name)" mode="#current"/>
    <xsl:apply-templates select="following-sibling::*[1]" mode="#current"/>
  </xsl:template>
  
  <xd:doc>
    <xd:desc>literal strings are tested against the string to be parsed</xd:desc>
    <xd:param name="remaining">The remaining unparsed portion of the string</xd:param>
  </xd:doc>
  <xsl:template match="literal[@dstring]" mode="e:parseTree">
    <xsl:param name="remaining" tunnel="yes" as="xs:string?"/>
    <xsl:variable name="match" as="xs:boolean" select="starts-with($remaining, @dstring)"/>
    <xsl:choose>
      <xsl:when test="$match">
        <e:literal>
          <xsl:value-of select="@dstring"/>
        </e:literal>
        <xsl:apply-templates select="following-sibling::*[1]" mode="#current">
          <xsl:with-param name="remaining" tunnel="yes" as="xs:string" select="normalize-space(substring-after($remaining, @dstring))"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <e:fail/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <xd:doc>
    <xd:desc>We don't need the text furniture of the grammar</xd:desc>
  </xd:doc>
  <xsl:template match="text()" mode="e:parseTree"/>
  
  <!-- parsing function -->
  
  <xd:doc>
    <xd:desc>This function parses $local.input with the default grammar</xd:desc>
    <xd:param name="local.input"/>
  </xd:doc>
  <xsl:function name="e:parse" as="element()?">
    <xsl:param name="local.input" as="xs:string"/>
    <xsl:sequence select="e:parse-with-grammar($local.input, $grammar)"/>
  </xsl:function>
  
  <xd:doc>
    <xd:desc>This function parses $local.input with a user defined grammar (e.g. where the grammar itself has been generated by a parse operation).</xd:desc>
    <xd:param name="local.input"/>
    <xd:param name="local.grammar"/>
  </xd:doc>
  <xsl:function name="e:parse-with-grammar" as="element()?">
    <xsl:param name="local.input" as="xs:string"/>
    <xsl:param name="local.grammar" as="document-node(element(ixml))"/>
    <xsl:variable name="parseTree" as="element()?">
      <xsl:apply-templates select="$local.grammar" mode="e:parseTree">
        <xsl:with-param select="$local.input" name="remaining" tunnel="yes" as="xs:string?"/>
      </xsl:apply-templates>
    </xsl:variable>
    <!-- Return entire parse Tree for now; replace later with 'pruned' result -->
    <xsl:sequence select="$parseTree"/>
  </xsl:function>
  
</xsl:stylesheet>