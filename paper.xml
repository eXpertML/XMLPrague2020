<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="resources/css/paper.css"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0">
	<info>
		<title>XSLT Earley: First Steps to a Declarative Parser Generator</title>
		<author>
			<personname>Tomos Hillman</personname>
			<email>tom@expertml.com</email>
			<uri>www.expertml.com</uri>
			<personblurb>
				<para>Tomos Hillman is the founder and principal of eXpertML Ltd, a consultancy specialising in
          XML, XSLT, XQuery and related technologies, particularly in the field of digital
          publishing, quality analysis, and transformation.</para>
				<para>Tom has given training courses to various institutions including publishers, universities, and the UN; he is a regular faculty member at the prestigious XML Summer School in Oxford, and one of the founding members of the Markup UK committee.</para>
				<para>Originally from Wales, he now lives with his family in Yorkshire. Tom doesn't like to conform to stereotypes, but a deep love of Star Wars, table top games, fiction and animation sometimes make this hard.</para>
			</personblurb>
			<affiliation>
				<orgname>eXpertML Ltd</orgname>
			</affiliation>
		</author>
		<keywordset>
			<keyword>XSLT 3.0</keyword>
			<keyword>Earley</keyword>
			<keyword>Invisible XML</keyword>
		</keywordset>
		<abstract>
			<para>Invisible XML <citation><xref linkend="Pemberton2013"/></citation> is a method for taking any structured
        text that can be parsed using a grammar, and treating it as XML. It means that the XML
        technology stack can be leveraged outside of XML structures.</para>
			<para>For Invisible XML to be useful in XSLT transforms, a grammar-based parser in XSLT is required. Parser-generators that provide XSLT parsers are available, but they don't create parsers that work in the XSLT programming idiom, and can't parse ambiguous grammars.</para>
			<para>An interpretation of the Earley <citation><xref linkend="Earley1970"/></citation> parsing algorithm may solve both of these problems: an Earley parser can parse any context-independent grammar, including any that may be ambiguous; it has also been suggested that the "Earley items" created as part of a parse operation can be reconfigured into a tree structure <citation><xref linkend="Sperberg-McQueen2017"/></citation>, which naturally lends itself to processing with XSLT.</para>
			<para>This paper aims to lay the ground-work for producing a parser generator that creates XSLT parsers for given grammars. Examples from previous papers on the topic will be used to manually create both an XML representation of the grammar, and the desired tree structure of Earley items. In turn, these should inform what an XSLT parser for that grammar should look like.</para>
			<para>Finally the paper will discuss how the resulting parser can be abstracted and extended so
        as to parse using an arbitrary grammar, to use other grammar languages, and to create an XSLT parser-generator.</para>
		</abstract>
	</info>
	<note>
		<title>Note for reviewers</title>
		<para>This paper is a (somewhat last minute) work in progress, and may be read as an extended
      abstract, rather than an incomplete paper (although the latter description is certainly
      accurate)!</para>
		<para>Where time hasn't allowed, or where work still has to be carried out, I have attempted to include headings to give a rough guide to reviewers on where I hope to go with the paper.</para>
	</note>
	<section>
    <title>Introduction</title>
    <para>This paper is a continuation of the work in papers on invisible XML and the Earley parser, particularly <citation><xref linkend="Pemberton2016"/></citation> and <citation><xref linkend="Sperberg-McQueen2017"/></citation>. It attempts to demonstrate an implementation of the Earley algorithm (<citation><xref linkend="Earley1970"/></citation>) - or something very close to it - using the declarative programming idiom of XSLT rather than its traditional, procedural form.</para>
    <para>The proof of concept that the paper aims to introduce is limited to a single pre-defined
      grammar; however it's hoped that this will form a groundwork for producing parsers and parser
      generators that can use not only any grammar, but grammars formed using a range of grammar
      languages, such as BNF and EBNF.</para>
    <section>
      <title>Invisible XML</title>
      <para>Invisible XML was introduced by Steven Pemberton in his 2013 paper at the Balisage
        conference (<citation><xref linkend="Pemberton2013"/></citation>), and specified online (<citation><xref linkend="ixmlSpec"/></citation>).</para>
      <para>It states that since all data is an abstraction, content can be equivalently expressed in a number of ways, including using XML. A simple piece of pseudo-code like: <example xml:id="input">
					<title>Proposed input</title>
					<programlisting>{a=0}</programlisting>
				</example> can be expressed without losing pertinent information in an XML format such as:</para>
			<example>
				<title>Expected Output</title>
				<programlisting language="xml">&lt;program>
   &lt;block>{
      &lt;statements>
         &lt;statement>
            &lt;assignment>
               &lt;variable>
                  &lt;identifier>a&lt;/identifier>
               &lt;/variable>
               =
               &lt;expression>
                  &lt;number>0&lt;/number>
               &lt;/expression>
            &lt;/assignment>
         &lt;/statement>;
         &lt;statements>
            &lt;empty>&lt;/empty>
         &lt;/statements>
      &lt;/statements>
   }&lt;/block>
&lt;/program></programlisting>
			</example>
      <para>This is the example we will use to create our parser; it is taken from the slides of
          <citation><xref linkend="Pemberton2016"/></citation></para>
      <para>Invisible XML also describes annotations to reduce those elements created in the parse
        tree that don't add meaning to the content but are an accident of the grammar formulation
        (such as the empty <code>statements</code> element).  Recreating these isn't a primary goal
        of this paper, but doing so shouldn't present great technical difficulty.</para>
    </section>
    <section>
      <title>XSLT parsers: why we should use them</title>
      <para>There's a number of features of Invisible XML that offer opportunities to process any data expressed in structured text. These can include documents (like Relax NG Compact, DTDs, XQuery, CSS, MarkDown, YAML, JSON, CSV, etc.), or formats embedded in XML (like path definitions in SVG, XSLT match patterns, or XPath statements).</para>
			<para>Expressing these data in an XML format allows us to use the XML technology stack to process them using tools like XQuery, XSLT, Schematron, and XSpec.  For many who already have existing XML resources and expertise, this not only allows for employee proficiencies and
        reuse of systems, but also works within the declarative idiom.</para>
			<para>A useful example would be in rules-based validation; <citation><xref linkend="Kosek2017"/></citation> gives the example of validating SVG paths, which use structured text within  an attribute:</para>
			<example>
				<title>An SVG Path <citation><xref linkend="Kosek2017"/></citation></title>
				<programlisting language="xml">&lt;path d="M100,200 C100,100 250,100 250,200 S400,300 400,200"/></programlisting>
			</example>
			<para>Usually, checking the content of such an attribute value would be achieved by regular expression matching and checking. This is often the quickest and simplest solution, and it might be the best solution for simple structured text examples.  Sometimes, however, even quite straightforward structured text grammars can require quite complicated and opaque regular expressions, leading to complex, verbose code which is hard to read and maintain.</para>
			<para>An Invisible XML approach not only provides validation through successful parsing of the structured text, but also allows validation of specific data and relationships within and between both XML and non-XML structured text. Kosek was able to demonstrate the ability to extend Schematron by including a parser based on the grammar of these paths as an XSLT inclusion, checking both validity via parse-ability:<example>
					<title>Schematron rule testing SVG Path validity <citation><xref linkend="Kosek2017"/></citation></title>
					<programlisting>&lt;sch:rule context="svg:path">
  &lt;sch:report test="p:parse-svg_path(@d)/
                    self::ERROR">
    &lt;sch:value-of select="p:parse-svg_path(@d)"/>
  &lt;/sch:report>
&lt;/sch:rule></programlisting>
				</example>as well as more specific rule constraints, such as ensuring paths are contained within a defined coordinate space:<example>
					<title>Schematron rule testing path coordinate ranges <citation><xref linkend="Kosek2017"/></citation></title>
					<programlisting>&lt;sch:rule context="svg:path">
  &lt;sch:let name="path"
           value="p:parse-svg_path(@d)"/>
  &lt;sch:assert
    test="every $c in $path//(signed-coordinate |
                      unsigned-coordinate)/number
          satisfies abs(number) le 1000">
  &lt;/sch:assert>
&lt;/sch:rule></programlisting>
				</example></para>
			<para>Having the parser available as XSLT therefore empowers developers who use any of the tools in the XSLT toolchain.</para>
    </section>
    <section>
      <title>LL1 parsers: why we can't always use them</title>
      <para>There is a limited availability of XSLT parsers; at the time of writing, there is one well known parser generator which can produce an XSLT parser from EBNF grammars:  <citation><xref linkend="REx"/></citation>.</para>
			<para>Whilst this freely available tool has been invaluable in enabling approaches like the one above, it has a few limitations.  One of these is that the parsers produced by <xref linkend="REx"/> are LL1 or similar based parsers, and can't parse all possible <emphasis>context free grammars</emphasis>.  In particular, they cannot parse <emphasis>ambiguous</emphasis> grammars; those which potentially allow for multiple valid parsed results, or multiple parsing routes resulting in the same results.</para>
			<para>The example  <xref linkend="grammar"/> chosen for this proof of concept was chosen precisely
        because the grammar chosen won't work with LL parsers <citation><xref linkend="Pemberton2016"/></citation>: the first available symbols in <code>assignment</code> and <code>block</code> are both <code>identifier</code>, and therefore the grammar is ambiguous.  It is perfectly possible in this case to rewrite the grammar so that it's not ambiguous through some clever abstractions, but this means that:<itemizedlist>
					<listitem>
						<para>using grammars may not be possible without careful editing</para>
					</listitem>
					<listitem>
						<para>editing of the grammars may not be obvious, straightforward, or result in a concise representation of the underlying concepts</para>
					</listitem>
					<listitem>
						<para>some grammars may not be used at all.</para>
					</listitem>
				</itemizedlist></para>
    </section>
    <section>
      <title>The declarative idiom: writing extensible parsers</title>
      <para>There is another limitation to using the <xref linkend="REx"/>: the parser that it produces is not only an LL1 parser, but it is a parser that is written in a functional, procedural paradigm, rather than the declarative idiom favoured by XSLT.</para>
			<para>The XSLT idiom involves match templates, "apply template" operations and native sequences.  The procedural approach of LL1 parsers involves  passing state objects between functions.  As well as being hard to understand, the latter approach is almost impossible to extend using XSLT's native import and precedence features.</para>
			<para>Consider a proposed XSLT parser for DTD documents.  It is relatively simple to find an EBNF grammar for the DTD syntax and apply it to a document, but this is unlikely to produce a complete parsed DTD: there is no way for EBNF to convey the meaning of entities and their expansions, and so entities will be treated as just another structure in the parse tree, without parsing any of the data which they represent.  Expanding and including the entities would involve recursive operations on the results of each parse.</para>
			<para>Better approaches may involve parsing the entities as they are defined, and including the results in the resulting parse tree; doing so would mean extending the generated parser with some bespoke code.  One of the goals of this paper is to establish whether (or not!) it is possible to write a generated parser that would allow extension using the well established XSLT methods of doing so: over-riding templates in including stylesheets, priorities, and use of instructions like <code>xsl:next-match</code> or <code>xsl:apply-imports</code>.</para>
    </section>
    <section>
      <title>The Earley Parser</title>
			<note>
				<title>Notes for reviewers</title>
				<para>This section will include a high level overview of the Earley Parser, including a demonstration of how Earley Items are calculated.</para>
				<para>It will also review the Earley Tree idea introduced by C M Sperberg-McQueen, and can compare nodes in the tree with the associated Earley Items.</para>
			</note>
    </section>
  </section>
	<section>
		<title>Methodology</title>
    <section>
      <title>Define a Grammar represented in XML</title>
    </section>
    <section>
      <title>Define the desired parsed output</title>
    </section>
    <section>
      <title>Determine the Earley objects</title>
    </section>
    <section>
      <title>Determine the Earley Tree</title>
    </section>
    <section>
      <title>The XSLT algorithm</title>
    </section>
	</section>
	<section>
		<title>Conclusions</title>
	</section>
	<section>
		<title>Future Work</title>
	</section>

	<bibliography xml:id="references">

		<bibliomixed xml:id="Earley1970" xreflabel="Earley 1970">Earley, Jay (1970), <title>An efficient context-free parsing algorithm</title>, Communications of the ACM 13 (2): 94-102, DOI: <biblioid class="doi">10.1145/362007.362035</biblioid>
		</bibliomixed>
		
		<bibliomixed xml:id="Pemberton2013" xreflabel="Pemberton 2013">Pemberton, Steven (2013), <title>Invisible XML</title>, Presented at Balisage: The Markup Conference 2013, Montréal, Canada, August 6 - 9, 2013. In <emphasis> Proceedings of Balisage: The Markup Conference 2013. </emphasis> Balisage Series on Markup Technologies, vol. 10 (2013). DOI: <biblioid class="doi">10.4242/BalisageVol10.Pemberton01</biblioid> . </bibliomixed>
		
		<bibliomixed xml:id="Pemberton2016" xreflabel="Pemberton 2016">Pemberton, Steven (2016), <title>Parse Earley, Parse Often</title>.  In Proc. XML London 2016, University College London, June 4-5, pp.120-126.  DOI: <biblioid class="doi">10.14337/XMLLondon16.Pemberton01</biblioid></bibliomixed>
		
		<bibliomixed xml:id="Kosek2017" xreflabel="Kosek 2017">Kosek, Jirka (2017) <title>Improving validation of structured text</title>. In Proc. XML London 2017, University College London, June 11–12, pp.56–67. DOI: <biblioid class="doi">10.14337/XMLLondon17.Kosek01</biblioid> .</bibliomixed>

	<bibliomixed xml:id="Sperberg-McQueen2017" xreflabel="Sperberg-McQueen 2017">Sperberg-McQueen, C. M (2017). <title>Translating imperative algorithms into declarative, functional terms: towards Earley parsing in XSLT and XQuery.</title> Presented at Balisage: The Markup Conference 2017, Washington, DC, August 1 - 4, 2017. In Proceedings of Balisage: The Markup Conference 2017. Balisage Series on Markup Technologies, vol. 19.  DOI:  <biblioid class="doi">10.4242/BalisageVol19.Sperberg-McQueen01</biblioid>.</bibliomixed>
		
    <bibliomixed xml:id="ixmlSpec" xreflabel="Invisible XML Specification">Pemberton, Steven (2019) <title>Invisible XML Specification (Draft)</title>, retrieved from the web on 2019-12-10  <link xlink:href="https://homepages.cwi.nl/~steven/ixml/ixml-specification.html" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"/></bibliomixed>
		
		<bibliomixed xml:id="REx" xreflabel="REx Parser Generator">Gunther Rademacher (2019) <title>REx Parser Generator</title>, retrieved from the web on 2019-12-10 <link xlink:href="https://www.bottlecaps.de/rex/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"/></bibliomixed>
		
	</bibliography>
	
	<appendix>
		<title>Code Listings</title>
		<example xml:id="grammar">
			<title>Invisible XML Grammar</title>
			<programlisting>program: block.
block: "{", statements, "}".
statements: statement, ";", statements; empty.
statement: if statement; while statement; assignment; call; block.
if statement: "if", condition, "then", statement, else-option.
else-option: "else", statement; empty.
empty: .
while statement: "while", condition, "do", statement.
assignment: variable, "=", expression.
variable: identifier.
call: identifier, "(", parameters, ")".</programlisting>
		</example>
		<example xml:id="xmlgrammar">
			<title>Grammar (iXML as XML format)</title>
			<programlisting>&lt;ixml>
  &lt;rule name="program">: 
    &lt;alt>
      &lt;nonterminal name="block"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="block">:
    &lt;alt>
      &lt;literal dstring="{"/>,
      &lt;nonterminal name="statements"/>,
      &lt;literal dstring="}"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="statements">:
    &lt;alt>
      &lt;nonterminal name="statement"/>,
      &lt;literal dstring=";"/>,
      &lt;nonterminal name="statements"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="empty"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="statement">:
    &lt;alt>
      &lt;nonterminal name="if statement"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="while statement"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="assignment"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="call"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="block"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="if statement">:
    &lt;alt>
      &lt;literal dstring="if"/>,
      &lt;nonterminal name="condition"/>,
      &lt;literal dstring="then"/>,
      &lt;nonterminal name="statement"/>,
      &lt;nonterminal name="else-option"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="else-option">:
    &lt;alt>
      &lt;literal dstring="else"/>,
      &lt;nonterminal name="statement"/>
    &lt;/alt>;
    &lt;alt>
      &lt;nonterminal name="empty"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="empty">:
    &lt;alt/>.
  &lt;/rule>
  &lt;rule name="while statement">:
    &lt;alt>
      &lt;literal dstring="while"/>,
      &lt;nonterminal name="condition"/>,
      &lt;literal dstring="do"/>,
      &lt;nonterminal name="statement"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="assignment">:
    &lt;alt>
      &lt;nonterminal name="variable"/>,
      &lt;literal dstring="="/>,
      &lt;nonterminal name="expression"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="variable">:
    &lt;alt>
      &lt;nonterminal name="identifier"/>
    &lt;/alt>.
  &lt;/rule>
  &lt;rule name="call">:
    &lt;alt>
      &lt;nonterminal name="identifier"/>,
      &lt;literal dstring="("/>,
      &lt;nonterminal name="parameters"/>,
      &lt;literal dstring=")"/>
    &lt;/alt>.
  &lt;/rule>
&lt;/ixml></programlisting>
		</example>
		<example xml:id="output">
			<title>Desired Output</title>
			<programlisting>&lt;program>
   &lt;block>{
      &lt;statements>
         &lt;statement>
            &lt;assignment>
               &lt;variable>
                  &lt;identifier>a&lt;/identifier>
               &lt;/variable>
               =
               &lt;expression>
                  &lt;number>0&lt;/number>
               &lt;/expression>
            &lt;/assignment>
         &lt;/statement>;
         &lt;statements>
            &lt;empty>&lt;/empty>
         &lt;/statements>
      &lt;/statements>
   }&lt;/block>
&lt;/program></programlisting>
		</example>
	  
    <table xml:id="earleyItems" frame="void">
      <caption>Earley Items for <code>{a=0}</code></caption>
      <colgroup>
        <col title="ItemNum" width="5%"/>
        <col title="Symbol" width="10%" align="right"/>
        <col title="Rule" align="char" char="◆" width="30%"/>
        <col title="StartState" width="5%"/>
        <col title="Notes" width="50%"/>
      </colgroup>
      <thead>
        <tr>
          <th>#</th>
          <th>Symbol</th>
          <th>Rule</th>
          <th>StartState</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th colspan="5">S(0) - ∧{a=0}</th>
        </tr>
        <tr>
          <td>1</td>
          <td>program</td>
          <td>→ ◆ block</td>
          <td>0</td>
          <td>Because the rule specifies a nonterminal, we have to <emphasis role="italic">predict</emphasis> the next rule, #2, for block</td>
        </tr>
        <tr>
          <td>2</td>
          <td>block</td>
          <td>→ ◆ "{" statements "}"</td>
          <td>0</td>
          <td>Now that the next symbol is the terminal symbol { we can <emphasis role="italic">scan</emphasis> to see if the input's next symbol matches. On a match, we create a modified Earley item #3 in the next state set, S(1)</td>
        </tr>
        <tr>
          <th colspan="5">S(1) - {∧a=0}</th>
        </tr>
        <tr>
          <td>3</td>
          <td>block</td>
          <td>→ "{" ◆ statements "}"</td>
          <td>0</td>
          <td>NB the starting point is unchanged. Now we can continue to <emphasis role="italic">predict</emphasis> and <emphasis role="italic">scan</emphasis> items #4 and #5 from the non-terminal statements.</td>
        </tr>
        <tr>
          <td>4</td>
          <td>statements</td>
          <td>→ ◆ empty</td>
          <td>1</td>
          <td>The start state for predictions is set to the current state number. This <emphasis role="italic">predicts</emphasis> #6</td>
        </tr>
        <tr>
          <td>5</td>
          <td>statements</td>
          <td>→ ◆ statement statements</td>
          <td>1</td>
          <td>Because there are many choices for statement, an item is predicted for each of those choices #7-11</td>
        </tr>
        <tr>
          <td>6</td>
          <td>empty</td>
          <td>→ ◆ </td>
          <td>1</td>
          <td>
            <para>This is our first <emphasis role="italic">completion</emphasis> (the ◆ marker is at the end of the rule).</para>
            <para>The start state is 1, so we look in <emphasis role="bold">S(1)</emphasis> for the rule that <emphasis role="italic">predicts</emphasis> 'empty' - i.e. item #4. We can then restate #4 as #12, moving the non-terminal to the left-hand side.</para>
          </td>
        </tr>
        <tr>
          <td>7</td>
          <td>statement</td>
          <td>→ ◆ if_statement</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">if_statement</emphasis></td>
        </tr>
        <tr>
          <td>8</td>
          <td>statement</td>
          <td>→ ◆ while_statment</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">while_statment</emphasis></td>
        </tr>
        <tr>
          <td>9</td>
          <td>statement</td>
          <td>→ ◆ assignment</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">assignment</emphasis></td>
        </tr>
        <tr>
          <td>10</td>
          <td>statement</td>
          <td>→ ◆ call</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">call</emphasis></td>
        </tr>
        <tr>
          <td>11</td>
          <td>statement</td>
          <td>→ ◆ block</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">block</emphasis></td>
        </tr>
        <tr>
          <td>12</td>
          <td>statements</td>
          <td>→ empty ◆ </td>
          <td>1</td>
          <td>a <emphasis role="italic">completion</emphasis> of #4 resulting in #13</td>
        </tr>
        <tr>
          <td>13</td>
          <td>block</td>
          <td>→ "{" statements ◆ "}"</td>
          <td>0</td>
          <td>a <emphasis role="italic">scan</emphasis> of the next character, 'a' will fail to match '{', so no further items are created from this parse branch</td>
        </tr>
        <tr>
          <td>14</td>
          <td>if_statement</td>
          <td>→ ◆ "if" condition "then" statement else-option</td>
          <td>1</td>
          <td>a <emphasis role="italic">scan</emphasis> of the next token fails; no further actions</td>
        </tr>
        <tr>
          <td>15</td>
          <td>while_statement</td>
          <td>→ ◆ "while" condition "do" statement</td>
          <td>1</td>
          <td>a <emphasis role="italic">scan</emphasis> of the next token fails; no further actions</td>
        </tr>
        <tr>
          <td>16</td>
          <td>assignment</td>
          <td>→ ◆ variable "=" expression</td>
          <td>1</td>
          <td><emphasis role="italic">predicts </emphasis> <emphasis role="bold">variable</emphasis></td>
        </tr>
        <tr>
          <td>17</td>
          <td>call</td>
          <td>→ ◆ identifier "(" parameters ")"</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">identifier</emphasis></td>
        </tr>
        <tr>
          <td>18</td>
          <td>block</td>
          <td>→ ◆ "{" statements "}"</td>
          <td>1</td>
          <td>a <emphasis role="italic">scan</emphasis> of the next token fails; no further actions</td>
        </tr>
        <tr>
          <td>19</td>
          <td>variable</td>
          <td>→ ◆ identifier</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">identifier</emphasis> - note that this is the same <emphasis role="italic">prediction</emphasis> that results from #17, so we don't need to run this twice...</td>
        </tr>
        <tr>
          <td>20</td>
          <td>identifier</td>
          <td>→ ◆ [abxy]</td>
          <td>1</td>
          <td>A <emphasis role="italic">scan</emphasis> of the next character ('a') succeeds - we can proceed to the first item of state S(2)</td>
        </tr>
        <tr>
          <th colspan="5">S(2) - {a∧=0}</th>
        </tr>
        <tr>
          <td>21</td>
          <td>identifier</td>
          <td>→ [abxy] ◆ </td>
          <td>1</td>
          <td>A <emphasis role="italic">completion</emphasis> of #20 resulting in #22 and #23</td>
        </tr>
        <tr>
          <td>22</td>
          <td>variable</td>
          <td>→ identifier ◆ </td>
          <td>1</td>
          <td>A <emphasis role="italic">completion</emphasis> of #19 resulting in #24</td>
        </tr>
        <tr>
          <td>23</td>
          <td>call</td>
          <td>→ identifier ◆ "(" parameters ")"</td>
          <td>1</td>
          <td>a <emphasis role="italic">scan</emphasis> of the next token fails; no further actions</td>
        </tr>
        <tr>
          <td>24</td>
          <td>assignment</td>
          <td>→ variable ◆ "=" expression</td>
          <td>1</td>
          <td>a <emphasis role="italic">scan</emphasis> of the next token matches, so we can create a new item and increment the start state</td>
        </tr>
        <tr>
          <th colspan="5">S(3) - {a=∧0}</th>
        </tr>
        <tr>
          <td>25</td>
          <td>assignment</td>
          <td>→ variable "=" ◆ expression</td>
          <td>1</td>
          <td><emphasis role="italic">predicts</emphasis> expression</td>
        </tr>
        <tr>
          <td>26</td>
          <td>expression</td>
          <td>→ ◆ number</td>
          <td>3</td>
          <td>(other potential non-terminal matches for expression are skipped here for brevity)</td>
        </tr>
        <tr>
          <td>27</td>
          <td>number</td>
          <td>→ ◆ [0-9]</td>
          <td>3</td>
          <td>An example of how to cope with '+' - it's equivalent to a choice between a single instance... </td>
        </tr>
        <tr>
          <td>28</td>
          <td>number</td>
          <td>→ ◆ [0-9] number</td>
          <td>3</td>
          <td>... or a single instance followed by the same non-terminal.</td>
        </tr>
        <tr>
          <th colspan="5">S(4) - {a=0∧}</th>
        </tr>
        <tr>
          <td>29</td>
          <td>number</td>
          <td>→ [0-9] ◆ </td>
          <td>3</td>
          <td>A <emphasis role="italic">completion</emphasis> of #27 resulting in 31</td>
        </tr>
        <tr>
          <td>30</td>
          <td>number</td>
          <td>→ [0-9]◆ number</td>
          <td>3</td>
          <td><emphasis role="italic">predicts</emphasis> <emphasis role="bold">number</emphasis> (#32 and #33)</td>
        </tr>
        <tr>
          <td>31</td>
          <td>expression</td>
          <td>→ number ◆ </td>
          <td>3</td>
          <td>A completion of #26 resulting in 34</td>
        </tr>
        <tr>
          <td>32</td>
          <td>number</td>
          <td>→ ◆ [0-9]</td>
          <td>4</td>
          <td>a scan of the next token fails; no further actions</td>
        </tr>
        <tr>
          <td>33</td>
          <td>number</td>
          <td>→ ◆ [0-9] number</td>
          <td>4</td>
          <td>a scan of the next token fails; no further actions</td>
        </tr>
        <tr>
          <td>34</td>
          <td>assignment</td>
          <td>→ variable "=" expression ◆ </td>
          <td>1</td>
          <td>A <emphasis role="italic">completion</emphasis> of #25 resulting in #35</td>
        </tr>
        <tr>
          <td>35</td>
          <td>statement</td>
          <td>→ assignment ◆ </td>
          <td>1</td>
          <td>A <emphasis role="italic">completion</emphasis> of #9 resulting in #36</td>
        </tr>
        <tr>
          <td>36</td>
          <td>statements</td>
          <td>→ statement ◆ statements</td>
          <td>1</td>
          <td>A <emphasis role="italic">completion</emphasis> of #5 resulting in #37 and #38 being a <emphasis role="italic">prediction</emphasis> for <emphasis role="bold">statements</emphasis></td>
        </tr>
        <tr>
          <td>37</td>
          <td>statements</td>
          <td>→ ◆ empty</td>
          <td>4</td>
          <td><emphasis role="italic">predicts</emphasis>
            <emphasis role="bold">empty</emphasis> #39</td>
        </tr>
        <tr>
          <td>38</td>
          <td>statements</td>
          <td>→ ◆ statement statements</td>
          <td>4</td>
          <td>We're going to skip the list of non-terminals here for brevity; it is left as an exercise for the reader to show that none of them will complete satisfactorily!</td>
        </tr>
        <tr>
          <td>39</td>
          <td>empty</td>
          <td>→ ◆ </td>
          <td>4</td>
          <td><emphasis role="italic">completes</emphasis> itself</td>
        </tr>
        <tr>
          <td>40</td>
          <td>statements</td>
          <td>→ empty ◆ </td>
          <td>4</td>
          <td><emphasis role="italic">completes </emphasis>#37</td>
        </tr>
        <tr>
          <td>41</td>
          <td>statements</td>
          <td>→ statement statements ◆ </td>
          <td>1</td>
          <td><emphasis role="italic">completes </emphasis>#36 giving #42 </td>
        </tr>
        <tr>
          <td>42</td>
          <td>block</td>
          <td>→ "{" statements ◆ "}"</td>
          <td>0</td>
          <td/>
        </tr>
        <tr>
          <th colspan="5">S(5) - {a=0}∧</th>
        </tr>
        <tr>
          <td>43</td>
          <td>block</td>
          <td>→ "{" statements "}" ◆ </td>
          <td>0</td>
          <td>Now we have a <emphasis role="italic">completion</emphasis> of the entire string, ending at the final state <emphasis role="bold">S(5)</emphasis> and beginning with the initial state <emphasis role="bold">S(0)</emphasis> - a successful parse!</td>
        </tr>
      </tbody>
    </table>
	  
		<example xml:id="earleyTrees">
			<title>Earley Tree</title>
			<programlisting/>
		</example>
	</appendix>

</article>
